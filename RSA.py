#NSA
'''
Fatorar n em p e q é difícil
'''
import random

#Cifracao: calcular c = m**e mod n
#Decifração: calcular d = c**d mod n
#Consistência: c**d = m**(e.d) = m mod n

def randomPrime(self, n):
        primo = number.getPrime(4096)
        return primo

def Egcd(self):
        #TODO implementa o bgl ai
        return 'kkkkkkk n ta implementado'

def invMod(self):
        #TODO implementa o invmod
        return 'kkkkkkk n ta implementado'

class RSA:
  def __init__(self, size):
    self.e = 3
    # Gerar dois números primos grandes (entre 512 e 4096 bits)


  # Calcular o módulo de n = p.q e o phi o(n) = (p - 1).(q - 1)
  # Escolher um número retativamente primo "e" 1 < e < o(n) como a chave pública
  # Calcular a chave privada d = e **(-1) mod o(n)